/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Pipe } from '@angular/core';
import { getProperty, isArray, isUndefined } from '../utils/utils';
var GroupByPipe = /** @class */ (function () {
    function GroupByPipe() {
    }
    /**
     * @param {?} input
     * @param {?} prop
     * @return {?}
     */
    GroupByPipe.prototype.transform = /**
     * @param {?} input
     * @param {?} prop
     * @return {?}
     */
    function (input, prop) {
        var e_1, _a;
        if (!isArray(input)) {
            return input;
        }
        /** @type {?} */
        var arr = {};
        try {
            for (var input_1 = tslib_1.__values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
                var value = input_1_1.value;
                /** @type {?} */
                var field = getProperty(value, prop);
                if (isUndefined(arr[field])) {
                    arr[field] = [];
                }
                arr[field].push(value);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return Object.keys(arr).map(function (key) { return ({ key: key, 'value': arr[key] }); });
    };
    GroupByPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'groupBy'
                },] }
    ];
    return GroupByPipe;
}());
export { GroupByPipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JvdXAtYnkucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItcGlwZXMvIiwic291cmNlcyI6WyJhZ2dyZWdhdGUvZ3JvdXAtYnkucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBQ3BELE9BQU8sRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRW5FO0lBQUE7SUF5QkEsQ0FBQzs7Ozs7O0lBcEJDLCtCQUFTOzs7OztJQUFULFVBQVUsS0FBVSxFQUFFLElBQVk7O1FBRWhDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDbkIsT0FBTyxLQUFLLENBQUM7U0FDZDs7WUFFSyxHQUFHLEdBQWtDLEVBQUU7O1lBRTdDLEtBQW9CLElBQUEsVUFBQSxpQkFBQSxLQUFLLENBQUEsNEJBQUEsK0NBQUU7Z0JBQXRCLElBQU0sS0FBSyxrQkFBQTs7b0JBQ1IsS0FBSyxHQUFRLFdBQVcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDO2dCQUUzQyxJQUFJLFdBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtvQkFDM0IsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztpQkFDakI7Z0JBRUQsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUN4Qjs7Ozs7Ozs7O1FBRUQsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFBLEdBQUcsSUFBSSxPQUFBLENBQUMsRUFBRSxHQUFHLEtBQUEsRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBNUIsQ0FBNEIsQ0FBQyxDQUFDO0lBQ25FLENBQUM7O2dCQXhCRixJQUFJLFNBQUM7b0JBQ0osSUFBSSxFQUFFLFNBQVM7aUJBQ2hCOztJQXVCRCxrQkFBQztDQUFBLEFBekJELElBeUJDO1NBdEJZLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGdldFByb3BlcnR5LCBpc0FycmF5LCBpc1VuZGVmaW5lZCB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuXHJcbkBQaXBlKHtcclxuICBuYW1lOiAnZ3JvdXBCeSdcclxufSlcclxuZXhwb3J0IGNsYXNzIEdyb3VwQnlQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XHJcblxyXG4gIHRyYW5zZm9ybShpbnB1dDogYW55LCBwcm9wOiBzdHJpbmcpOiBBcnJheTxhbnk+IHtcclxuXHJcbiAgICBpZiAoIWlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcnI6IHsgW2tleTogc3RyaW5nXTogQXJyYXk8YW55PiB9ID0ge307XHJcblxyXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpbnB1dCkge1xyXG4gICAgICBjb25zdCBmaWVsZDogYW55ID0gZ2V0UHJvcGVydHkodmFsdWUsIHByb3ApO1xyXG5cclxuICAgICAgaWYgKGlzVW5kZWZpbmVkKGFycltmaWVsZF0pKSB7XHJcbiAgICAgICAgYXJyW2ZpZWxkXSA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhcnJbZmllbGRdLnB1c2godmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhhcnIpLm1hcChrZXkgPT4gKHsga2V5LCAndmFsdWUnOiBhcnJba2V5XSB9KSk7XHJcbiAgfVxyXG59XHJcbiJdfQ==